#ifndef _SM4_H
#define _SM4_H
#include<stdio.h>
#include<time.h>
#include<iomanip>
#include<stdlib.h>

typedef unsigned int word;

// 密钥扩展
// param:   
//		mk[4]: 加密密钥
// return: 轮密钥
word* keyExpansion(word mk[4]);

// 迭代
// param¿
//		x[4]: 加密结果
//		mk[4]:密钥 128 bits
//		flag: true：加密  flase:解密
void encryption(word x[4],word mk[4],bool flag);

// sm4加密，CBC模式
// param¿
//		result：加密结果
// 		arr	  ：待加密数据
//		bits  ：待加密数据的bit数
// 		mk[4] ：密钥，128 bits
// return： 加密结果result的bit数
unsigned int sm4_encryption(word*& result,word*& arr,unsigned int bits,word mk[4]);

// sm4解密，CBC模式
// param¿ 
//		result: 解密结果
//		arr   : 待解密数据
//		bits  : 待解密数据的bit数
//      mk[4] : 密钥，128 bits
// return： 解密结果result的bit数
unsigned int sm4_decryption(word*& result,word*& arr,unsigned int bits,word mk[4]);



const word S[] = {
	0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, //0
	0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, //1
	0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, //2
	0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, //3
	0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, //4
	0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, //5
	0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, //6
	0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, //7
	0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, //8
	0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, //9
	0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, //A
	0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, //B
	0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, //C
	0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, //D
	0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, //E
	0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48  //F
};

#define ShiftLeft(x,k) (x>>(32-k)|(x<<k))
#define L(x) (x^ShiftLeft(x,2)^ShiftLeft(x,10)^ShiftLeft(x,18)^ShiftLeft(x,24))//¿¿¿¿L
#define LL(x) (x^ShiftLeft(x,13)^ShiftLeft(x,23))//¿¿¿¿¿¿¿¿¿
#define F(x) (T(x))
#define lamda(x) ((S[x >> 24 & 0xff] << 24) | (S[x >> 16 & 0xff] << 16) | (S[x >> 8 & 0xff] << 8) | S[x & 0xff])//¿¿¿¿¿

//密钥扩展函数
word* keyExpansion(word mk[4]){
	word* rk=new word[32];
	word Fk[4]={ 0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc };
	word CK[32],k[4];
	for(int i=0;i<32;i++){
		CK[i]=0;
		for(int j=0;j<4;j++)
			CK[i]=CK[i]*256+((4*i+j)*7)%256;
	}
	for(int i=0;i<4;i++){
		k[i]=mk[i]^Fk[i];
	}
	word temp;
	for(int i=0;i<32;i++){
		temp = k[1] ^ k[2] ^ k[3] ^ CK[i];
		temp = lamda(temp);
		temp = k[0] ^ LL(temp);
		k[0]=k[1];k[1]=k[2];k[2]=k[3];k[3]=temp;
		rk[i]=temp;
	}
	return rk;
}

//迭代
void encryption(word x[4],word mk[4],bool flag){
	word temp;
	word* rk=keyExpansion(mk);
	for(int i=0;i<32;i++){
		temp = x[1] ^ x[2] ^ x[3];
		if (flag == false) temp ^= rk[31 - i];
		else temp ^= rk[i];
		temp = lamda(temp);
		temp = L(temp)^x[0];
		x[0]=x[1];x[1]=x[2];x[2]=x[3];x[3]=temp;
	}
	temp=x[0];x[0]=x[3];x[3]=temp;
	temp=x[1];x[1]=x[2];x[2]=temp;
	delete[] rk;
}

//sm4加密函数，CBC模式
unsigned int sm4_encryption(word*& result,word*& arr,unsigned int bits,word mk[4]){//return bits
	word* temp;
	unsigned int temp_size;
	unsigned int s=128-bits%128;//s:填充的比特数
	if(s==0)s=128;
	else if(s==1)s+=128;
	temp_size=4+((bits+s)>>5);

	temp=new unsigned int[temp_size];

	int i;
	for(i=4;i<4+((bits+31)>>5);i++)
		temp[i]=arr[i-4];
	for(;i<temp_size;i++)
		temp[i]=0;
	temp[i-1]|=s;//用零填充，最后8比特用s填充

	srand((int)time(0));
	for(i=0;i<4;i++)
		temp[i]=rand();//前128比特为初始向量
	result=new unsigned int[temp_size];
	for(i=0;i<4;i++)
		result[i]=temp[i];
	for(i=4;i<temp_size;i+=4){
		result[i]=temp[i]^result[i-4];
		result[i+1]=temp[i+1]^result[i-3];
		result[i+2]=temp[i+2]^result[i-2];
		result[i+3]=temp[i+3]^result[i-1];
		encryption(&result[i],mk,true);
	}
	return temp_size*32;
}

//sm4解密，CBC模式
unsigned int sm4_decryption(word*& result,word*& arr,unsigned int bits,word mk[4]){
	unsigned int size=bits/32-4;	
	result=new unsigned int[size];
	unsigned int i;
	for(i=0;i<size;i+=4){
		result[i]=arr[i+4];
		result[i+1]=arr[i+5];
		result[i+2]=arr[i+6];
		result[i+3]=arr[i+7];
		encryption(&result[i],mk,false);
		result[i]^=arr[i];
		result[i+1]^=arr[i+1];
		result[i+2]^=arr[i+2];
		result[i+3]^=arr[i+3];
	}
	i=result[size-1]&0xff;
	return size*32-i;
}

#endif

